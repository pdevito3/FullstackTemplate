namespace FullstackTemplate.SourceGenerators;

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator]
public sealed class ValueObjectGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
				transform: static (ctx, ct) => Transform(ctx, ct))
			.Where(static x => x.HasValue)
			.Select(static (x, _) => x!.Value);

		context.RegisterSourceOutput(provider, static (spc, info) => Generate(spc, info));
	}

	private static ValueObjectInfo? Transform(GeneratorSyntaxContext ctx, CancellationToken ct)
	{
		var classDecl = (ClassDeclarationSyntax)ctx.Node;
		var symbol = ctx.SemanticModel.GetDeclaredSymbol(classDecl, ct);
		if (symbol is null)
			return null;

		if (!InheritsFrom(symbol, "ValueObject"))
			return null;

		var members = ImmutableArray.CreateBuilder<MemberEntry>();

		var current = symbol;
		while (current is not null && current.Name != "ValueObject")
		{
			foreach (var m in current.GetMembers())
			{
				ct.ThrowIfCancellationRequested();

				if (m is IPropertySymbol
					{
						DeclaredAccessibility: Accessibility.Public,
						IsStatic: false,
						GetMethod: not null
					} prop
					&& !HasAttribute(prop, "IgnoreMemberAttribute"))
				{
					var isNonNullableValueType = prop.Type.IsValueType
						&& prop.NullableAnnotation != NullableAnnotation.Annotated;
					members.Add(new MemberEntry(prop.Name, isNonNullableValueType));
				}
				else if (m is IFieldSymbol
					{
						DeclaredAccessibility: Accessibility.Public,
						IsStatic: false,
						IsConst: false
					} field
					&& !HasAttribute(field, "IgnoreMemberAttribute"))
				{
					var isNonNullableValueType = field.Type.IsValueType
						&& field.NullableAnnotation != NullableAnnotation.Annotated;
					members.Add(new MemberEntry(field.Name, isNonNullableValueType));
				}
			}

			current = current.BaseType;
		}

		if (members.Count == 0)
			return null;

		return new ValueObjectInfo(
			symbol.ContainingNamespace.ToDisplayString(),
			symbol.Name,
			members.ToImmutable());
	}

	private static bool InheritsFrom(INamedTypeSymbol symbol, string baseName)
	{
		var current = symbol.BaseType;
		while (current is not null)
		{
			if (current.Name == baseName)
				return true;
			current = current.BaseType;
		}

		return false;
	}

	private static bool HasAttribute(ISymbol symbol, string attributeName)
	{
		foreach (var attr in symbol.GetAttributes())
		{
			if (attr.AttributeClass?.Name == attributeName)
				return true;
		}

		return false;
	}

	private static void Generate(SourceProductionContext ctx, ValueObjectInfo info)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine($"namespace {info.Namespace};");
		sb.AppendLine();
		sb.AppendLine($"partial class {info.ClassName}");
		sb.AppendLine("{");

		// Equals
		sb.AppendLine("\tpublic override bool Equals(object? obj)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tif (obj is null || obj.GetType() != GetType())");
		sb.AppendLine("\t\t\treturn false;");
		sb.AppendLine($"\t\tvar other = ({info.ClassName})obj;");

		if (info.Members.Length == 1)
		{
			sb.AppendLine($"\t\treturn Equals({info.Members[0].Name}, other.{info.Members[0].Name});");
		}
		else
		{
			sb.Append("\t\treturn ");
			for (var i = 0; i < info.Members.Length; i++)
			{
				if (i > 0)
					sb.Append("\t\t\t&& ");
				sb.Append($"Equals({info.Members[i].Name}, other.{info.Members[i].Name})");
				sb.AppendLine(i < info.Members.Length - 1 ? "" : ";");
			}
		}

		sb.AppendLine("\t}");
		sb.AppendLine();

		// GetHashCode
		sb.AppendLine("\tpublic override int GetHashCode()");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tunchecked");
		sb.AppendLine("\t\t{");
		sb.AppendLine("\t\t\tvar hash = 17;");

		foreach (var m in info.Members)
		{
			if (m.IsNonNullableValueType)
				sb.AppendLine($"\t\t\thash = hash * 23 + {m.Name}.GetHashCode();");
			else
				sb.AppendLine($"\t\t\thash = hash * 23 + ({m.Name}?.GetHashCode() ?? 0);");
		}

		sb.AppendLine("\t\t\treturn hash;");
		sb.AppendLine("\t\t}");
		sb.AppendLine("\t}");

		sb.AppendLine("}");

		ctx.AddSource($"{info.ClassName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}
}

internal readonly struct ValueObjectInfo : System.IEquatable<ValueObjectInfo>
{
	public string Namespace { get; }
	public string ClassName { get; }
	public ImmutableArray<MemberEntry> Members { get; }

	public ValueObjectInfo(string ns, string className, ImmutableArray<MemberEntry> members)
	{
		Namespace = ns;
		ClassName = className;
		Members = members;
	}

	public bool Equals(ValueObjectInfo other) =>
		Namespace == other.Namespace
		&& ClassName == other.ClassName
		&& Members.SequenceEqual(other.Members);

	public override bool Equals(object? obj) => obj is ValueObjectInfo other && Equals(other);

	public override int GetHashCode()
	{
		unchecked
		{
			var hash = (Namespace.GetHashCode() * 397) ^ ClassName.GetHashCode();
			foreach (var m in Members)
				hash = (hash * 397) ^ m.GetHashCode();
			return hash;
		}
	}
}

internal readonly struct MemberEntry : System.IEquatable<MemberEntry>
{
	public string Name { get; }
	public bool IsNonNullableValueType { get; }

	public MemberEntry(string name, bool isNonNullableValueType)
	{
		Name = name;
		IsNonNullableValueType = isNonNullableValueType;
	}

	public bool Equals(MemberEntry other) =>
		Name == other.Name && IsNonNullableValueType == other.IsNonNullableValueType;

	public override bool Equals(object? obj) => obj is MemberEntry other && Equals(other);

	public override int GetHashCode() => (Name.GetHashCode() * 397) ^ IsNonNullableValueType.GetHashCode();
}
